Cosign Demo: Deploy Procedures (EKS + AKS)

This document contains copy/paste commands to deploy signed and unsigned demo workloads to both AWS EKS and Azure AKS, plus the PEM public keys for your admission controller. It assumes:
- EKS cluster: cosign-demo (region: us-east-1)
- AKS cluster: aks-cosign-9f2d7c in resource group rg-cosign-aks-8a7f2c (region: eastus)
- ACR: acrcosign7k2b3c
- AWS KMS key alias: alias/cosign-ec-p256 (EC P-256)
- Azure Key Vault: czim-cosign with key name cosign-ec-p256 (EC P-256)
- GitHub Actions OIDC configured for both clouds and workflows present in .github/workflows


1) Public Keys (paste into your admission controller)
----------------------------------------------------

AWS (KMS EC P-256)
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEWb6eIC5LvfJAvdbD3xMkbe89DQ7i
iLCAVs6YJtYz9ZMD4Xoh1vEVdALLBQ32lx17YJ/4SS1UjroUiK6mksKVng==
-----END PUBLIC KEY-----
SHA256: 0d8dcef02055d0b9269dfe8b34badf6d20e5c91cdfa5d3fb89002f59075f2fd7

Azure (Key Vault EC P-256)
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEIuT0I1xQBwq8f88zbkdwGdZ4WYfL
1rOINL4JEEd3uHi0Qc4716iTkG1+1McKe2nHVw4gxd9rx8171z1Ji/2Cig==
-----END PUBLIC KEY-----
SHA256: 28f57276b7f0bfd2fca71d164ecbb5a8aafafabdbd57d1064ebb42eeacbc47f7

Local copies saved:
- keys/aws-cosign-public.pem
- keys/azure-cosign-public.pem


2) Unified AWS EKS Deploy (signed or unsigned)
----------------------------------------------

# Signed (set sign=true and provide kms_key_ref)
gh workflow run eks-deploy.yml \
  -f aws_region=us-east-1 \
  -f cluster_name=cosign-demo \
  -f ecr_repo=cosigndemo-nginx \
  -f source_image=docker.io/library/alpine:3.20 \
  -f tag=demo-$(date +%s) \
  -f namespace=demo \
  -f deployment_name=nginx \
  -f sign=true \
  -f kms_key_ref=alias/cosign-ec-p256

# Unsigned (set sign=false)
gh workflow run eks-deploy.yml \
  -f aws_region=us-east-1 \
  -f cluster_name=cosign-demo \
  -f ecr_repo=cosigndemo-unsigned \
  -f source_image=docker.io/library/alpine:3.20 \
  -f tag=unsigned-$(date +%s) \
  -f namespace=demo-unsigned \
  -f deployment_name=nginx-unsigned \
  -f sign=false

# Check rollout
aws eks update-kubeconfig --name cosign-demo --region us-east-1
kubectl get pods -n demo -o wide


3) Deploy: Unsigned to AWS EKS (expect block once policy is set)
---------------------------------------------------------------

gh workflow run unsigned-deploy-eks.yml \
  -f image_ref=nginx:1.27-alpine \
  -f aws_region=us-east-1 \
  -f cluster_name=cosign-demo \
  -f namespace=demo-unsigned \
  -f deployment_name=nginx-unsigned \
  -f container_name=nginx

# Inspect events for admission rejection
 kubectl get events -n demo-unsigned --sort-by=.lastTimestamp | tail -20


4) Unified Azure AKS Deploy (signed or unsigned)
------------------------------------------------

# Signed (set sign=true and provide kv_name)
gh workflow run aks-deploy.yml \
  -f acr_name=acrcosign7k2b3c \
  -f aks_resource_group=rg-cosign-aks-8a7f2c \
  -f aks_cluster_name=aks-cosign-9f2d7c \
  -f kv_name=czim-cosign \
  -f kv_key_name=cosign-ec-p256 \
  -f source_image=docker.io/library/alpine:3.20 \
  -f tag=demo-$(date +%s) \
  -f namespace=demo \
  -f deployment_name=nginx \
  -f sign=true

# Check rollout
az aks get-credentials -g rg-cosign-aks-8a7f2c -n aks-cosign-9f2d7c --overwrite-existing
kubectl get pods -n demo -o wide


# Unsigned (set sign=false)
gh workflow run aks-deploy.yml \
  -f acr_name=acrcosign7k2b3c \
  -f aks_resource_group=rg-cosign-aks-8a7f2c \
  -f aks_cluster_name=aks-cosign-9f2d7c \
  -f source_image=docker.io/library/alpine:3.20 \
  -f tag=unsigned-$(date +%s) \
  -f namespace=demo-unsigned-aks \
  -f deployment_name=nginx-unsigned-aks \
  -f sign=false

# Inspect events for admission rejection
kubectl get events -n demo-unsigned-aks --sort-by=.lastTimestamp | tail -20


5a) Create an UNSIGNED image in AWS ECR (for AWS demo)
-----------------------------------------------------

# Copy an upstream image to your ECR without signing
gh workflow run ecr-copy-unsigned.yml \
  -f source_image=docker.io/library/alpine:3.20 \
  -f ecr_repo=cosigndemo-unsigned \
  -f tag=unsigned-$(date +%s) \
  -f aws_region=us-east-1

# The resulting image URL will be:
# 037842804132.dkr.ecr.us-east-1.amazonaws.com/cosigndemo-unsigned:<TAG>

# Deploy that exact ECR URL via the existing unsigned EKS workflow
gh workflow run unsigned-deploy-eks.yml \
  -f image_ref=037842804132.dkr.ecr.us-east-1.amazonaws.com/cosigndemo-unsigned:<TAG> \
  -f aws_region=us-east-1 \
  -f cluster_name=cosign-demo \
  -f namespace=demo-unsigned \
  -f deployment_name=nginx-unsigned \
  -f container_name=nginx


6) Local Signature Verification (optional)
------------------------------------------

# ECR image (replace with your repo/tag)
cosign verify --key keys/aws-cosign-public.pem \
  <ACCOUNT>.dkr.ecr.us-east-1.amazonaws.com/cosigndemo-nginx:<TAG>

# ACR image (replace with your tag)
cosign verify --key keys/azure-cosign-public.pem \
  acrcosign7k2b3c.azurecr.io/cosigndemo-nginx:<TAG>


7) Policy Snippet (Kyverno example)
-----------------------------------

verifyImages:
- imageReferences:
  - "*.dkr.ecr.*.amazonaws.com/cosigndemo-nginx:*"
  - "acrcosign7k2b3c.azurecr.io/cosigndemo-nginx:*"
  attestors:
  - count: 1
    entries:
    - keys:
        publicKeys: |
          -----BEGIN PUBLIC KEY-----
          MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEWb6eIC5LvfJAvdbD3xMkbe89DQ7i
          iLCAVs6YJtYz9ZMD4Xoh1vEVdALLBQ32lx17YJ/4SS1UjroUiK6mksKVng==
          -----END PUBLIC KEY-----
    - keys:
        publicKeys: |
          -----BEGIN PUBLIC KEY-----
          MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEIuT0I1xQBwq8f88zbkdwGdZ4WYfL
          1rOINL4JEEd3uHi0Qc4716iTkG1+1McKe2nHVw4gxd9rx8171z1Ji/2Cig==
          -----END PUBLIC KEY-----


8) Notes
--------
- Workflows referenced:
  - .github/workflows/aws-kms-sign-and-deploy-eks.yml
  - .github/workflows/azure-kv-sign-and-deploy-aks.yml
  - .github/workflows/unsigned-deploy-eks.yml
  - .github/workflows/azure-unsigned-deploy-aks.yml
- Azure Key URI format (for reference): azurekms://czim-cosign.vault.azure.net/keys/cosign-ec-p256
- If your controller trusts both PEMs, either AWS- or Azure-signed images will be admitted.
