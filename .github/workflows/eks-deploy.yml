name: eks-deploy

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: "AWS region (ECR/EKS)"
        required: true
        default: "us-east-1"
      cluster_name:
        description: "EKS cluster name"
        required: true
        default: "cosign-demo"
      ecr_repo:
        description: "ECR repository name (created if missing)"
        required: true
        default: "cosigndemo-nginx"
      source_image:
        description: "Upstream image to copy (e.g., docker.io/library/alpine:3.20)"
        required: true
        default: "docker.io/library/alpine:3.20"
      tag:
        description: "Tag to apply to the image"
        required: true
        default: "manual"
      namespace:
        description: "Kubernetes namespace"
        required: true
        default: "demo"
      deployment_name:
        description: "Deployment name"
        required: true
        default: "nginx"
      sign:
        description: "Sign image with AWS KMS?"
        type: boolean
        required: true
        default: true
      kms_key_ref:
        description: "KMS key alias or ARN (required if sign=true)"
        required: false

permissions:
  id-token: write
  contents: read
  packages: read

jobs:
  run:
    name: Copy → (Sign) → Deploy to EKS
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ github.event.inputs.aws_region }}
      CLUSTER_NAME: ${{ github.event.inputs.cluster_name }}
      NAMESPACE: ${{ github.event.inputs.namespace }}
      DEPLOYMENT_NAME: ${{ github.event.inputs.deployment_name }}
      SOURCE_IMAGE: ${{ github.event.inputs.source_image }}
      ECR_REPO: ${{ github.event.inputs.ecr_repo }}
      TAG: ${{ github.event.inputs.tag }}
      PUBLIC_ECR_ALIAS: ${{ vars.PUBLIC_ECR_ALIAS || 'o7c6t4i0' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS account ID
        id: sts
        run: echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to Amazon ECR Public (increase pull limits)
        run: |
          # ECR Public auth is global in us-east-1
          aws ecr-public get-login-password --region us-east-1 \
            | docker login --username AWS --password-stdin public.ecr.aws

      - name: Ensure ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPO" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$ECR_REPO" >/dev/null

      - name: Ensure ECR Public repo exists
        run: |
          aws ecr-public describe-repositories --repository-names "$ECR_REPO" --region us-east-1 >/dev/null 2>&1 || \
          aws ecr-public create-repository --repository-name "$ECR_REPO" --region us-east-1 >/dev/null

      - name: Copy upstream image to ECR (with ECR Public auth, fallback + digest)
        id: push
        run: |
          set -euo pipefail
          ECR_URI=${{ steps.sts.outputs.account_id }}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}
          SRC="$SOURCE_IMAGE"
          pull_with_retry() {
            img="$1"; attempts=${2:-6};
            for i in $(seq 1 "$attempts"); do
              if docker pull "$img"; then
                return 0
              fi
              sleep $(( 5 * i ))
            done
            return 1
          }
          echo "Pulling $SRC"
          if ! pull_with_retry "$SRC"; then
            echo "Primary pull failed; attempting public ECR mirror for official images..."
            case "$SRC" in
              docker.io/library/nginx:*) MIRROR="public.ecr.aws/docker/library/nginx:${SRC##*:}" ;;
              nginx:*)                   MIRROR="public.ecr.aws/docker/library/nginx:${SRC##*:}" ;;
              docker.io/library/alpine:*) MIRROR="public.ecr.aws/docker/library/alpine:${SRC##*:}" ;;
              alpine:*)                   MIRROR="public.ecr.aws/docker/library/alpine:${SRC##*:}" ;;
              *) MIRROR="" ;;
            esac
            if [ -n "$MIRROR" ]; then
              echo "Trying mirror: $MIRROR"
              pull_with_retry "$MIRROR"
              SRC="$MIRROR"
            else
              echo "No mirror configured for $SRC" >&2
              exit 1
            fi
          fi
          docker tag  "$SRC" "$ECR_URI:$TAG"
          docker push "$ECR_URI:$TAG"

          PUBLIC_URI="public.ecr.aws/${PUBLIC_ECR_ALIAS}/${ECR_REPO}"
          docker tag  "$SRC" "$PUBLIC_URI:$TAG"
          docker push "$PUBLIC_URI:$TAG"

          PRIVATE_DIGEST=$(aws ecr describe-images --repository-name "$ECR_REPO" --image-ids imageTag="$TAG" --query 'imageDetails[0].imageDigest' --output text)
          PUBLIC_DIGEST=$(aws ecr-public describe-images --repository-name "$ECR_REPO" --image-ids imageTag="$TAG" --region us-east-1 --query 'imageDetails[0].imageDigest' --output text)

          echo "image_ref_private=$ECR_URI@$PRIVATE_DIGEST" >> $GITHUB_OUTPUT
          echo "image_ref_public=$PUBLIC_URI@$PUBLIC_DIGEST" >> $GITHUB_OUTPUT
          echo "image_ref=$PUBLIC_URI@$PUBLIC_DIGEST" >> $GITHUB_OUTPUT
          echo "image_uri_private=$ECR_URI:$TAG" >> $GITHUB_OUTPUT
          echo "image_uri_public=$PUBLIC_URI:$TAG" >> $GITHUB_OUTPUT
          {
            echo "Private digest: $PRIVATE_DIGEST"
            echo "Public digest:  $PUBLIC_DIGEST"
            echo "Public URI:     $PUBLIC_URI"
          } >> $GITHUB_STEP_SUMMARY

      - name: Install cosign
        if: ${{ inputs.sign }}
        uses: sigstore/cosign-installer@v3

      - name: Sign with AWS KMS (optional)
        if: ${{ inputs.sign }}
        env:
          COSIGN_YES: "true"
        run: |
          if [ -z "${{ github.event.inputs.kms_key_ref }}" ]; then
            echo "kms_key_ref is required when sign=true" >&2
            exit 1
          fi
          KEY_URI="awskms:///${{ github.event.inputs.kms_key_ref }}"
          cosign sign --key "$KEY_URI" "${{ steps.push.outputs.image_ref_private }}"
          cosign sign --key "$KEY_URI" "${{ steps.push.outputs.image_ref_public }}"
          cosign verify --key "$KEY_URI" "${{ steps.push.outputs.image_ref_private }}"
          cosign verify --key "$KEY_URI" "${{ steps.push.outputs.image_ref_public }}"
          cosign public-key --key "$KEY_URI" > aws-cosign-public.pem
          echo "Saved aws-cosign-public.pem"
      
      - name: Upload public key (if signed)
        if: ${{ inputs.sign }}
        uses: actions/upload-artifact@v4
        with:
          name: aws-cosign-public
          path: aws-cosign-public.pem

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.0"

      - name: Install eksctl (for IAM identity mapping)
        run: |
          curl -sSL -o /tmp/eksctl.tar.gz "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$(uname -s | tr '[:upper:]' '[:lower:]')_amd64.tar.gz"
          tar -xzf /tmp/eksctl.tar.gz -C /tmp && sudo mv /tmp/eksctl /usr/local/bin/eksctl
          eksctl version || true

      - name: Map GitHub OIDC role into cluster-admin (idempotent)
        env:
          ROLE_ARN: ${{ vars.AWS_DEPLOY_ROLE_ARN }}
        run: |
          eksctl create iamidentitymapping \
            --cluster "$CLUSTER_NAME" \
            --region  "$AWS_REGION" \
            --arn     "$ROLE_ARN" \
            --username github-actions \
            --group    system:masters || true

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"

      - name: Preflight cluster auth
        run: |
          kubectl version --short || true
          kubectl config current-context || true
          kubectl cluster-info || true

      - name: Render and apply manifests
        run: |
          mkdir -p rendered
          export NAMESPACE DEPLOYMENT_NAME
          export CONTAINER_NAME=${DEPLOYMENT_NAME}
          export IMAGE_REF="${{ steps.push.outputs.image_ref_public }}"
          envsubst < kavedarr/deploy/eks/k8s/namespace.yaml  > rendered/namespace.yaml
          envsubst < kavedarr/deploy/eks/k8s/deployment.yaml > rendered/deployment.yaml
          envsubst < kavedarr/deploy/eks/k8s/service.yaml    > rendered/service.yaml
          kubectl apply -f rendered/namespace.yaml
          kubectl apply -f rendered/deployment.yaml
          kubectl apply -f rendered/service.yaml

      - name: Wait for rollout
        run: kubectl rollout status deploy/$DEPLOYMENT_NAME -n "$NAMESPACE" --timeout=180s
