name: unsigned-deploy-eks

on:
  workflow_dispatch:
    inputs:
      image_ref:
        description: "Image to deploy WITHOUT signing (e.g., nginx:1.27-alpine)"
        required: true
        default: "nginx:1.27-alpine"
        type: string
      aws_region:
        description: "AWS region of EKS cluster"
        required: true
        default: "us-east-1"
      cluster_name:
        description: "EKS cluster name"
        required: true
        default: "cosign-demo"
        type: string
      namespace:
        description: "Kubernetes namespace to deploy"
        required: true
        default: "demo-unsigned"
      deployment_name:
        description: "Kubernetes Deployment name"
        required: true
        default: "nginx-unsigned"
      container_name:
        description: "Container name in Deployment"
        required: true
        default: "nginx"
      role_arn:
        description: "AWS IAM Role ARN for GitHub OIDC (if omitted, uses repo var AWS_DEPLOY_ROLE_ARN)"
        required: false
        type: string

permissions:
  id-token: write    # needed for AWS OIDC (but NOT for signing)
  contents: read
  packages: read

env:
  AWS_REGION: ${{ github.event.inputs.aws_region }}
  CLUSTER_NAME: ${{ github.event.inputs.cluster_name }}
  NAMESPACE: ${{ github.event.inputs.namespace }}
  DEPLOYMENT_NAME: ${{ github.event.inputs.deployment_name }}
  CONTAINER_NAME: ${{ github.event.inputs.container_name }}
  IMAGE_REF: ${{ github.event.inputs.image_ref }}

jobs:
  deploy-unsigned:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ⚠️ WARNING - Deploying UNSIGNED image
        run: |
          echo "::warning::This workflow deploys UNSIGNED container images"
          echo "::warning::Image: $IMAGE_REF (NO COSIGN SIGNATURE)"
          echo "::warning::This should be BLOCKED by admission controller"

      - name: Configure AWS credentials (OIDC)
        id: awscreds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ github.event.inputs.role_arn || vars.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.0"

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"

      - name: Create namespace if missing
        run: |
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"
          kubectl label namespace "$NAMESPACE" cosign-demo=unsigned --overwrite

      - name: Render manifests (UNSIGNED)
        run: |
          mkdir -p rendered
          export NAMESPACE DEPLOYMENT_NAME CONTAINER_NAME IMAGE_REF
          echo "Rendering manifests for UNSIGNED deployment:"
          echo "- Namespace: $NAMESPACE"
          echo "- Deployment: $DEPLOYMENT_NAME" 
          echo "- Image: $IMAGE_REF (UNSIGNED)"
          envsubst < kavedarr/deploy/eks/k8s/namespace.yaml > rendered/namespace.yaml
          envsubst < kavedarr/deploy/eks/k8s/deployment.yaml > rendered/deployment.yaml
          envsubst < kavedarr/deploy/eks/k8s/service.yaml > rendered/service.yaml

      - name: Apply manifests (expect admission controller to BLOCK)
        run: |
          echo "Attempting to deploy UNSIGNED image..."
          echo "Admission controller should REJECT this deployment!"
          kubectl apply -f rendered/namespace.yaml
          kubectl apply -f rendered/deployment.yaml || echo "Deployment blocked by admission controller (expected)"
          kubectl apply -f rendered/service.yaml || echo "Service creation may have failed due to blocked deployment"

      - name: Check deployment status
        run: |
          echo "Checking if deployment was blocked..."
          kubectl get deploy/$DEPLOYMENT_NAME -n "$NAMESPACE" || echo "Deployment not found (blocked by admission controller)"
          kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -10