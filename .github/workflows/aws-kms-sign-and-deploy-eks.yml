name: aws-kms-sign-and-deploy-eks

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: "AWS region for ECR/KMS/EKS"
        required: true
        default: "us-east-1"
      ecr_repo:
        description: "ECR repository name (will be created if missing)"
        required: true
        default: "cosigndemo-nginx"
      cluster_name:
        description: "EKS cluster name"
        required: true
      kms_key_ref:
        description: "AWS KMS key alias or ARN (e.g., alias/cosign-ec-p256)"
        required: true
      namespace:
        description: "Kubernetes namespace"
        required: true
        default: "demo"
      deployment_name:
        description: "Deployment name"
        required: true
        default: "nginx"
      container_name:
        description: "Container name"
        required: true
        default: "nginx"
      role_arn:
        description: "AWS IAM Role ARN for OIDC (fallback: vars.AWS_DEPLOY_ROLE_ARN)"
        required: false
        type: string
      alpine_tag:
        description: "Alpine tag to base the image on"
        required: true
        default: "3.20"
      tag:
        description: "Tag to apply to the pushed image"
        required: true
        default: "manual"

permissions:
  id-token: write
  contents: read
  packages: read

jobs:
  run:
    name: Build → ECR → Cosign(KMS) → EKS
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ github.event.inputs.aws_region }}
      CLUSTER_NAME: ${{ github.event.inputs.cluster_name }}
      NAMESPACE: ${{ github.event.inputs.namespace }}
      DEPLOYMENT_NAME: ${{ github.event.inputs.deployment_name }}
      CONTAINER_NAME: ${{ github.event.inputs.container_name }}
      ECR_REPO: ${{ github.event.inputs.ecr_repo }}
      TAG: ${{ github.event.inputs.tag }}
      KMS_KEY_REF: ${{ github.event.inputs.kms_key_ref }}
      ALPINE_TAG: ${{ github.event.inputs.alpine_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ github.event.inputs.role_arn || vars.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS account ID
        id: sts
        run: echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPO" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$ECR_REPO" >/dev/null

      - name: Build and push image (Alpine base)
        id: push
        run: |
          set -euo pipefail
          ECR_URI=${{ steps.sts.outputs.account_id }}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}
          docker pull alpine:${ALPINE_TAG}
          docker tag  alpine:${ALPINE_TAG} "$ECR_URI:$TAG"
          docker push "$ECR_URI:$TAG"
          echo "image_ref=$ECR_URI:$TAG" >> $GITHUB_OUTPUT

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign image with AWS KMS
        env:
          COSIGN_YES: "true"
        run: |
          cosign sign --key awskms:///${KMS_KEY_REF} "${{ steps.push.outputs.image_ref }}"

      - name: Verify signature (KMS key)
        run: |
          cosign verify --key awskms:///${KMS_KEY_REF} "${{ steps.push.outputs.image_ref }}"

      - name: Export public key (PEM) for admission controller
        run: |
          cosign public-key --key awskms:///${KMS_KEY_REF} > aws-cosign-public.pem

      - name: Upload public key artifact
        uses: actions/upload-artifact@v4
        with:
          name: aws-cosign-public
          path: aws-cosign-public.pem

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.0"

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"

      - name: Render and apply manifests
        run: |
          mkdir -p rendered
          export NAMESPACE DEPLOYMENT_NAME CONTAINER_NAME
          export IMAGE_REF="${{ steps.push.outputs.image_ref }}"
          envsubst < kavedarr/deploy/eks/k8s/namespace.yaml  > rendered/namespace.yaml
          envsubst < kavedarr/deploy/eks/k8s/deployment.yaml > rendered/deployment.yaml
          envsubst < kavedarr/deploy/eks/k8s/service.yaml    > rendered/service.yaml
          kubectl apply -f rendered/namespace.yaml
          kubectl apply -f rendered/deployment.yaml
          kubectl apply -f rendered/service.yaml

      - name: Wait for rollout
        run: kubectl rollout status deploy/$DEPLOYMENT_NAME -n "$NAMESPACE" --timeout=180s
